## 说明
业界的埋点方案主要分为以下三类：
- 代码埋点：在需要埋点的节点调用接口，携带数据上传。如百度统计等
- 可视化埋点：使用可视化工具进行配置化的埋点，即所谓的「无痕埋点」，前端在页面加载时，可以读取配置数据，自动调用接口进行埋点。如开源的Mixpanel;
- 无埋点：前端自动采集全部事件并上报埋点数据。如国内的神策数据等；

> 在当时排期紧凑，人力紧缺的情况下，显然不允许我们去开发可视化埋点方案和无埋点方案，所以只能采取代码埋点方案。

**命令式埋点**
命令式埋点，顾名思义，开发者需要手动在需要埋点的节点处进行埋点。如点击按钮或链接后的回调函数、页面ready时进行请求的发送。大家肯定都很熟悉这样的代码：
```javascript
// 页面加载时发送埋点请求
$(document).ready(function(){
  // ... 这里存在一些业务逻辑
  sendRequest(params);
});
// 按钮点击时发送埋点请求
$('button').click(function(){
  // ... 这里存在一些业务逻辑
  sendRequest(params);
});
```
可以很容易发现，这样的做法很有可能会将埋点代码侵入业务代码，这使整体业务代码变得繁琐，容易出错，且后续代码会愈加膨胀，难以维护。所以，我们需要让埋点的代码与具体的业务逻辑解耦，即 声明式埋点 ，从而提高埋点的效率和代码的可维护性。

**声明式埋点**
理论上，声明式埋点只需要关注两个问题：
- 需要埋点的DOM节点；
- 所需携带的数据

因此，可以很快想出一个声明式埋点的方法
```html
// key表示埋点的唯一标识；act表示埋点方式
<button data-stat="{key:'111', act: 'click'}">埋点</button>
```
那么可以去遍历DOM树，找到 [data-stat] 的节点，给这个button绑上click事件，把这些参数在回调函数中通过请求发出去。
在DOM节点(html)上声明埋点，与业务逻辑（通常在Javascript文件中）就解耦了。调用也很方便。
看起来很美，但这样就能解决问题了吗？显然是不够的。还需要解决以下问题：
- 遍历DOM树的时机问题，一个简单的例子，一个表格的行数据是通过异步加载，而表格行中的操作按钮需要埋点，那么在DOM ready的时候去遍历，显然是无法找到的
- 绑定埋点事件次数的问题，怎样保证埋点事件不会被重复绑定到元素上，一次操作发了N个埋点请求?
- 如何处理特有的埋点行为，如页面展现埋点，区域展现埋点?
- 如何在解绑时，销毁已绑定的事件?

## Vue单页面项目埋点

### 按钮
在项目入口文件 main.js 中配置我们的自定义指令
```javascript
Vue.directive('stat', {
    bind(el, binding) {
        el.addEventListener(
            'click',
            () => {
                const data = binding.value
                // 使用项目封装好的http或者axios
                http.request({
                    // todo 修改正确的地址
                    url: '/mock/stat',
                    params: {
                        ...data,
                    },
                })
            },
            false,
        )
    },
})
```

```html
 <el-button v-stat="{ name: '获取nodes' }">获取nodes</el-button>
```
### 页面
使用路由拦截统计页面级别的 PV

> 使用 vue-router 的 beforeEach 或者 afterEach 钩子上报数据，具体使用哪个最好是根据业务逻辑来选择

```
router.afterEach((to, from, next) => {
    const meta = to.meta
    const { title } = meta
    const { path } = to
    http.request({
        // todo 修改正确的地址
        url: '/mock/stat',
        params: {
            title,
            path,
        },
    })
})

```